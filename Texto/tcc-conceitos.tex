\chapter{CONCEITOS FUNDAMENTAIS} 
\label{conceitos}
%https://www.automate.org/robotics/tech-papers/optimizing-robotic-precision-unleash-real-time-performance-with-advanced-foundational-software-solutions
Este capítulo aborda os conceitos teóricos e as ferramentas utilizadas no desenvolvimento deste trabalho, com o intuito de descrever e relacionar estes conceitos, para que haja um entendimento claro nas etapas subsequentes. 
\textcolor{blue}{É importante também apresentar, como cada um desses conceitos e tecnologias se relacionam com o objetivo central deste estudo.}

O principal conceito a ser abordado é a 
Conteinerização, uma forma de virtualização feita para ser mais rápida e flexível que a emulação, é um processo de implantação que consegue ser executado em diversos dispositivos e sistemas operacionais. Isso ocorre pelo fato de que um contêiner consegue armazenar os arquivos e bibliotecas para ser executado, permitindo a um usuário executar uma aplicação de outro sistema operacional no sistema operacional que o mesmo possua. Além disso, o contêiner permite que falhas ocorram sem afetar outros processos que não estão agrupados no mesmo. \cite{Wen2023}. 
\begin{comment}
    One of the most formidable adversaries in this type of software development is “jitter” response. This term alludes to the deviation in timing, manifesting as rapid, small, and often unpredictable variations or fluctuations in a robot’s movements, positions, or behaviors. Jitter is highly undesirable as it can result in imprecise actions, leading to erroneous outcomes, and in the worst-case scenarios, it may induce instability in robotic systems, compelling them to revert to predefined safe states. The importance of minimizing jitter cannot be overstated, especially in applications where precision and accuracy are paramount.
    
    Yet, jitter represents just the tip of the iceberg of performance challenges. The second protagonist in this narrative is “latency.” Latency refers to delay or time lag between an input or action and the corresponding response or output within a robotic system. It is an inevitable aspect of any robotic system since instantaneous response with zero latency is a technological impossibility. The crux of the matter is to determine how much latency is acceptable in any given context. The higher or more unbounded the latency, the greater its potential to disrupt the reliability, accuracy, and precision of robotic systems.
\end{comment}
\textcolor{blue}{Além do conceito da conteinerização, é importante conhecer sobre o jitter, que é um problema presente no mundo da robótica e do desenvolvimento de softwares. Jitter é um termo utilizado para o desvio de tempo, causando variações ou flutuações indesejáveis e imprevisíveis nos movimentos e comportamentos do robô, causando ações imprecisas que resultam em erros e, em casos mais graves, podendo forçar o sistema do robô a modos de segurança. 
Mesmo com esses problemas, o jitter não é o maior problema com relação a problemas de desempenho, existe também a 
latência, que é o atraso entre a entrada dos dados (input) até a “saída” (output) no sistema robótico, é um problema inevitável que acontece por ser um limite tecnológico ainda não solucionado. Quanto maior for a latência, maior o potencial de problemas com a precisão do sistema robótico.
As características de isolamento e empacotamento da conteinerização são extremamente importantes para este trabalho, por ser necessário entender se essa camada adicional introduz atrasos, consumo excessivo de recursos ou variações no desempenho do robô. A partir deste conceito, aplica-se o Docker, utilizado para fazer a conteinerização,} o 
Docker que é uma plataforma utilizada para desenvolvimento, envio e funcionamento de aplicações de maneira separada da infraestrutura por conta da conteinerização. Por conta deste fator, o usuário consegue gerir as aplicações da mesma maneira que gera sua infraestrutura. Outro fator importante é que o Docker permite que as aplicações desenvolvidas sejam testadas e executadas com menos atraso do que a maneira convencional. Contêineres são bons para fluxos de integrações e entregas de trabalho contínuas. \cite{dck2025}

\textcolor{blue}{O Docker, foi utilizado no robô para realizar os testes, para isso, foi utilizado o} Robot Operating System 2 (ROS 2), que é um meta-sistema operacional. \textcolor{red}{Um sistema operacional para robôs} \textcolor{blue}{Um meta-sistema operacional não é um sistema operacional completo o mesmo adiciona novas funções para o sistema operacional base, no caso do ROS 2, o mesmo possui um foco maior para a robótica}, ele realiza funções similares a outros sistemas operacionais, com exceção do controle de CPU, pois executa processos robóticos (planejamento de movimento, navegação, manipulação de objetos, entre outros), fluxos de dados, entre outros e possui bibliotecas e ferramentas que executam códigos em múltiplos computadores. Este conceito é utilizado pelo ROS 2, um dos 
\textcolor{red}{métodos} \textcolor{blue}{conjuntos de ferramentas e bibliotecas para o desenvolvimento de aplicações} 
mais utilizado nos robôs atuais, sendo uma camada acima de um sistema operacional real, que oferece abstrações e serviços para os sistemas robóticos.
O ROS 2 é justamente um meta-sistema operacional de código aberto utilizado para auxiliar a desenvolver aplicações para robôs. O mesmo possui serviços que outros sistemas operacionais normalmente possuem, mas com o foco maior para a área da robótica, facilitando comunicação entre processos, funções que se comunicam com as demais e entre muitos outros. Para o desenvolvimento do projeto, foi utilizado o ROS 2, que mantém o conceito modular e distribuído, mas possui melhorias e mais funcionalidades que o ROS original (Figura \ref{fig:ROS25}) \cite{ros2025}. 

\textcolor{red}{Para conectar as aplicações, foram utilizados Data Distribution Service (DDS), que são protocolos Middleware.} \textcolor{blue}{Para conectar o Docker com o sistema operacional, foram utilizados Middlewares,} os
Middlewares são uma camada de software que conecta as aplicações a um sistema operacional, permitindo uma comunicação e compartilhamento de dados mais simples entre os componentes de um sistema. Esta facilidade permite que os desenvolvedores foquem no desenvolvimento das principais funções de uma aplicação, pois a comunicação entre a aplicação e o sistema operacional está sendo feita pelo middleware. \cite{mdw2025}
\textcolor{red}{O DDS é} \textcolor{blue}{Os Middlewares utilizados são DDS, que é} um protocolo middleware e uma API para conexão centrada em dados, este protocolo integra os componentes de um sistema que muitas aplicações precisam, como arquitetura escalável, confiabilidade e prover conectividade de dados de baixa latência. Este protocolo foi criado pela Object Management Group (OMG). \cite{dds2025} Para este projeto, foram utilizados dois tipos de DDS, o primeiro é o
Fast DDS uma implementação de DDS feita em C++ que possui uma biblioteca que oferece uma API e protocolo de comunicação que disponibiliza um modelo Publisher-Subscriber centrado em dados. Este modelo visa ser eficiente e confiável para distribuir as informações para o sistema em tempo real. \cite{fdds2025} O segundo DDS utilizado é o
Cyclone DDS, que é uma implementação de DDS com alto desempenho, permite que os desenvolvedores que o utilizam possam criar gêmeos digitais das entidades de seus sistemas, permitindo compartilhar estados, eventos, fluxos de dados e mensagens pela rede em tempo real, visa ser rápido, consistente e seguro. \cite{cdds2025}

\textcolor{red}{Os testes simulados foram executados em modelos baseados na arena presente na sala K4-04 do Centro Universitário FEI, para isso, foi utilizado o software}
\textcolor{blue}{Todos esses conceitos, foram utilizados nos testes simulados, realizados em uma arena simulada baseada na arena presente na sala K4-04 do centro universitário FEI, essa arena junto dos testes foram executados no software}
Gazebo Simulator Classic que é um software usado para desenvolver simulações, possui diversos projetos de código aberto para que os interessados possam utilizar e desenvolver suas próprias simulações. Neste software estão presentes também diversos modelos, tanto como objetos como também robôs (Figura \ref{fig:gzb25}). \cite{gzb2025} 
\textcolor{red}{Para realizar estes testes, foi utilizado o modelo virtual do robô}
\textcolor{blue}{Para se realizar os testes, foi escolhido um robô presente no centro universitário FEI, com documentação e versões simuladas para uso, esse robô é o}
TurtleBot3 Burger (Figura \ref{fig:tbt3b25}) que é um robô customizável de preço acessível ao público baseado no modelo ROS para ser utilizado como um material educativo, de pesquisas, entretenimento pessoal e etc, é um robô que foi desenvolvido com o intuito de ser barato, por conta disto, o mesmo não possui uma grande funcionalidade ou qualidade, mas o mesmo compensa na relação da quantidade de aplicações que o mesmo consegue realizar. \cite{turtlebot3_manual}.
\textcolor{red}{Para verificar o desempenho do computador durante a execução dos testes,} 
\textcolor{blue}{Durante a execução dos testes, para se obter os dados do robô e então se realizar a comparação,} 
foi utilizada a ferramenta Nigel's Monitor (Nmon), um administrador, otimizador e avaliador de desempenho de sistemas para o sistema operacional Linux que mostra importantes informações de desempenho do computador, como CPU, memória RAM, disco, kernel, entre outros. O mesmo pode fornecer as informações diretamente pelo terminal ou salvar em um arquivo para o usuário. \cite{nmon2025}

\begin{figure}[htb]
    \caption{Exemplo do ROS 2, utilizando turtlesim, ROS e RQT}
    \includegraphics[width=0.4\linewidth]{Figures/ROS.png}
    \caption*{Fonte: Autores}
    \caption*{Legenda: A figura apresenta apenas um exemplo em que são utilizados o ROS 2, turtlesim e RQT, sendo apenas o ROS 2, utilizado no projeto }
    \label{fig:ROS25}
\end{figure}

\begin{figure}[htb]
    \caption{Exemplo utilizando o Gazebo Simulator Classic}
    \includegraphics[width=0.6\linewidth]{Figures/Gazebo.png}
    \caption*{Fonte: Autores}
    \caption*{Legenda: A figura apresenta a versão base da arena utilizada para os testes realizados no projeto}
    \label{fig:gzb25}
\end{figure}

\begin{figure}[htb]
    \caption{TurtleBot3 Burger}
    \includegraphics[width=0.35\linewidth]{Figures/TurtleBot3.jpg}
    \caption*{Fonte: FOUNDATION, 2025}
    \label{fig:tbt3b25}
\end{figure}
