\chapter{TRABALHOS RELACIONADOS}
\label{trabs}

\novo{Este capítulo apresenta trabalhos que tratam de conteinerização de forma próxima a proposta deste trabalho, ou seja, tanto sobre a comparação de desempenho no uso de contêiner quanto do uso com o ROS para projetos de robótica.}

\anot{DESENVOLVER, COLOCAR METODOLOGIA DOS PROJETOS}
\section{Bare-Metal vs. Hypervisors and Containers: Performance Evaluation of Virtualization Technologies for Software-Defined Vehicles}

% \begin{itemize}
%     \item Materiais:
%     \item Métodos:
%     \item Métricas:
% \end{itemize}

% \textbf{Resumo}

% \textbf{Contribuições}

% \textbf{Limitações}

\ante{O projeto de Wen et. al. (2023), auxilia com relação ao entendimento da conteinerização em sistemas embarcados e também com relação ao seu desempenho.No artigo, é detalhada}
\novo{O artigo de \citeonline{Wen2023} detalha }
a utilização de diferentes formas de conteinerização e seu efeito no desempenho em diferentes tipos de hardware. Foram realizados testes gerais que envolviam CPU, memória, rede e disco, em três ambientes diferentes: 
\ante{máquina virtual, contêiner e um contêiner dentro de uma máquina virtual.}
\novo{Integrado (utilizando uma Raspberry Pi 4 Modelo B), Computador desktop (Dell Optiplex 7040 PC) e uma estação de trabalho customizada de alto desempenho}
\novo{Para realizar estes testes, foram utilizados Whetstone (versão 1.2), Dhrystone (versão 2.2a) e Kcbench (0.9.5), ferramentas de medição de desempenho, para realizar os testes de CPU. Os testes de memória foram medidos pelo software RAMspeed (versão 3.5.0). Foi utilizado o iperf3 (versão 3.9) para medir os testes de rede, enquanto para analisar o desempenho do disco, utilizou-se o Dbench (versão 4.00), Bonnie++ (versão 2.00) e o Sysbench (versão 1.0.20). Foram utilizados e analisados diversos contêineres engine, sendo estes o Docker (versão 20.10.17), KVM (v1.25.3), Podman (versão 3.4.4) e Systemd-Nspawn (versão 249.11). Para realizar os testes em diversos contêineres, foi utilizada uma versão leve do Kubernetes, o k3s (versão V1.25.3). Foi utilizado o Autoware, um framework para realizar simulações de condução autônoma, para verificar a inicialização dos ambientes virtualizados e contêinerizados.}

\novo{Os testes de CPU consistiam em avaliar o desempenho no bare-metal (servidor físico que é de uso exclusivo para apenas um cliente, sem a camada de virtualização que fica entre o hardware e o sistema operacional), contêineres (Docker e Podman) e em virtualizações (KVM). Para isso, utilizou-se o Whetstone para realizar 50 milhões de cálculos de ponto flutuante para medir a eficiência da CPU (a métrica usada foi o mflops, que são as milhões de operações realizadas por segundo), o Dhrystone para executar um código de cálculo simples continuamente, para analisar as operações comuns da computação (onde analisou as interações realizadas por segundo como métrica) e o Kcbench para compilar o código do kernel do Linux e medir quanto tempo para a CPU completar a tarefa (utilizou-se a métrica de Kernel/hora).
Ao medir a memória, foi utilizado o RAMspeed, que analisa a velocidade da escrita e leitura na memória e quanto tempo se leva para realizar essas operações, repetindo este processo várias vezes nas três plataformas (a métrica para este teste foi a velocidade de escrita e leitura por segundo).
Para os testes de rede, utilizaram o iperf3, que mede a largura de banda de envio e recebimento de dados por meio de transmissões TCP e UDP (o Throughput, sendo a taxa de transferência, e a latência foram as métricas deste teste).
Por último, foi analisado o desempenho do disco, que foi medido pelo Dbench, que simula uma aplicação de operações de Input/Output em sistemas de arquivos, e o Bonnie++, que testa arquivos realizando operações de criação, leitura, gravação e exclusão de arquivos (as métricas usadas foram throughput de leitura e gravação, medido em megabytes por segundo, e o tempo para criar e excluir arquivos)}.
Com isso, foi concluído que as máquinas virtuais e os contêineres possuem um desempenho semelhante ao bare-metal, onde entre a CPU, rede e memória, sofria uma perda de no máximo 5\% enquanto no disco a diferença era de até 35\%. Foi observado que o Docker e a KVM (máquina virtual baseada no Kernel) foram 5 a 10\% mais lentos que o bare-metal, com o Docker sendo mais lento ainda na primeira inicialização, mas levando a concluir que conteinerização e virtualização podem ser utilizados em aplicações para automóveis. \novo{Este trabalho auxilia no entendimento da aplicação e avaliação de ambientes conteinerizados físicos e virtualizados. Para o desenvolvimento deste trabalho, serão utilizadas as análises realizadas com relação ao Docker e suas aplicações}.

\begin{comment}
- CPU: Whetstone, Dhrystone, Kcbench
- Memória: RAMspeed
- Rede: iPerf3
- Disco: Dbench, Bonnie++, Sysbench
Além disso, o framework Autoware (utilizado para simulação de condução autônoma) foi testado em ambientes virtualizados e contêinerizados para medir o impacto na inicialização do sistema, que é crucial para aplicações automotivas.
\end{comment}
\section{Docker Performance Evaluation across Operating Systems}

O
\ante{trabalho}
\novo{artigo}
de \citeonline{SMKD2024} auxilia no entendimento dos conceitos de avaliação do Docker com relação a outros sistemas operacionais.
\novo{Este estudo realiza testes onde o Docker é executado em diversos sistemas operacionais instalados em um MacBook Pro 13, com uma CPU da Intel i5-8257u @ 1.40GHz, 16GB LPDDR3 2133 Mhz de RAM e  256GB NVME SSD de armazenamento, com a versão 4.20 do Docker Engine e configurado para utilizar 8 CPUs lógicos, 16GB de RAM e 1GB de memória swap}.
Para verificar a diferença entre os sistemas operacionais, 
\ante{foram utilizados sistemas operacionais recém-instalados que eram macOS Ventura, Ubuntu 22.04 e Windows 10 rodando em um MacBook Pro 13}
\novo{foram utilizados os sistemas operaiocnais MacOS Ventura 13.5.1, Ubuntu 22.04-6.4.8-t2-jammy e Windows 10 22H2 recem-instalados}.
\ante{Os testes consistiam em estressar o Docker com relação à CPU, rede e na resiliência do mesmo.}
\novo{Neste projeto, o objetivo foi estressar o Docker para medir o desempenho da CPU usando um programa escrito em linguagem C para realizar o cálculo de Pi pela fórmula de Leibniz, sendo a métrica escolhida o tempo de execução do programa. Outro teste foi o teste do Sysbench, em que eram realizados cálculos dos números primos para verificar o desempenho do processador, com as métricas sendo a quantidade de operações por segundo.}

\novo{Além disso, foram feitas diversas leituras e gravações aleatórias e sequenciais no disco rígido para medir o tempo de resposta e taxa de transferência das operações (teste de Input/Output). As métricas foram os testes de leitura e escrita.
O teste do Iperf3 foi realizado a comunicação entre contêineres usando o protocolo TCP, depois utilizando o UDP, e por último a comunicação entre o host e o contêiner usando novamente o TCP. Este teste tinha como foco verificar o desempenho da rede, as métricas usadas foram Throughput (taxa de transferência) em TCP e UDP e a perda de pacotes.
Em seguida, foi realizado o teste utilizando o 7Zip, em que era medida a velocidade de compactação e descompactação dos arquivos, e verificar o comportamento e desempenho do Docker e do sistema operacional.
Foi realizado o teste de verificação de desempenho de um banco de dados no Docker, foi utilizado o Pgbench, onde era medida a taxa de transações por segundo (TPS) e verificado como o desempenho variava.
Por último, foi feito o teste de Apache slowhttp attack, em que foram abertas diversas conexões HTTP lentas e, com isso, testada a capacidade e resistência ao sofrer um ataque de negação de serviço (Denial of Service - DoS) e verificar qual sistema acabou sofrendo mais. Foi medido o tempo de resposta durante o ataque DoS.}
Após realizar os testes, foi observado que o sistema operacional possui uma importante influência sobre o desempenho presente no conteiner. Alguns possuíam benefícios em relação a outros em uma determinada categoria. O macOS se destacou com relação aos dados obtidos nas configurações utilizadas nos sistemas docker, não sofrendo grandes perdas de desempenho, se mostrando extremamente versátil,
o Linux se mostrou mais eficiente quanto às aplicações que raramente utilizam escrita no disco, se mostrando uma escolha melhor que o MacOS com relação a bancos de dados em memória, cache e entre outros, pois por não necessitarem de tanta escrita, essas aplicações se beneficiam mais quando executadas em um conteiner com Linux,
o Windows acabou não se beneficiando tanto quanto os outros, a não ser pela taxa de transferência de rede entre os contêineres. Assim como o Linux, o Windows possui problemas com a velocidade em que a escrita é feita e com isso.
\ante{Este artigo auxilia no entendimento com relação aos tipos de testes que podem ser realizados para analisar o desempenho do Docker, auxiliando de uma maneira que possa ser um pontapé inicial para o desenvolvimento dos testes com o Docker, e como medir o desempenho de um contêiner}
\novo{Este trabalho auxilia com o entendimento sobre o desempenho do Docker em diferentes sistemas operacionais, mostrando qual opção mais se aplica a este trabalho, que no caso deste trabalho, foi o Linux, por ser mais acessível que o macOS e por possuir um desempenho superior ao do Windows, além de mostrar tipos de testes que podem ser realizados para verificar o desempenho e quais métricas utilizar}.

\section{DA Containerized Microservice Architecture for a ROS 2 Autonomous Driving Software: An End-to-End Latency Evaluation}

\ante{Conforme Wen et. al. (2024), o artigo} 
\novo{O trabalho de \citeonline{Wen2024}} 
aborda a arquitetura baseada em microserviços para sistemas automotivos 
\novo{autônomos usando ROS 2}. 
Cada serviço foi 
\ante{realizado}
\novo{executado} em contêineres separados, pois os testes realizados identificaram que este método é viável e acaba por melhorar a latência existente em sistemas operacionais Linux sem contêineres, que obteve uma latência de 5 a 8\% end-to-end, além de reduzir a latência máxima, o que mostra a vantagem no uso de conteinerização para os sistemas automotivos em tempo real.
\novo{Neste projeto foram utilizados duas plataformas de computação distintas, uma com arquitetura x86 (InoNet Mayflower-B17) e outra aarch64 (Armv8 ADLINK AVA COM-HPC) com ambos utilizando o sistema operacional Ubuntu 22.04.3 LTS Jammy Jellyfish, GPU NVIDIA RTX A6000 48 GB e Kernel 6.2.0-34-generic, foi utilizado o ROS 2 Humble Hawksbill com o middleware Eclipse CycloneDDS, Docker engine (versão 24.0.5), k3s (versão v1.27.3+k3s1)}.
Foi concluído que o ROS 2, utilizado para avaliar a arquitetura de microserviços para uma aplicação real de direção autônoma, foi de extrema importância por conta de sua arquitetura distribuída que é baseada em nós e possui comunicação DDS, o que levou ao isolamento das funções do veículo e facilitou a migração para contêineres. Na conteinerização, o ROS 2 perde um pouco de seu desempenho, mas em aplicações complexas como o Autoware, a mesma acaba por
\ante{melhorar}
\novo{ter um desempenho melhor},
reduzindo o uso de CPU e memória. 
\ante{Este artigo auxilia no entendimento do uso da conteinerização com relação ao ROS 2, seus problemas e seus acertos}
\novo{Este artigo demostrou que o uso de containeres para o tipo de problema proposto neste trabalho é viável e que pode trazer benefícios em relação a execução em bare-metal}.